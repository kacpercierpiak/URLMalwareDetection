using Cyber.URLPhishing.Domain;
using Cyber.URLPhishing.Domain.Models.Response;
using Microsoft.Extensions.Logging;
using Nager.PublicSuffix;
using System.Collections.Concurrent;
using System.Net;
using System.Text.RegularExpressions;

namespace Cyber.URLPhishing.Application.Services
{
    public class URLService : IURLService
    {
        private readonly ILogger _logger;
        private readonly IURLRepository _urlRepository;

        public URLService(ILogger<URLService> logger, IURLRepository urlRepository)
        {
            _logger = logger;
            _urlRepository = urlRepository;
        }


        public async Task<UrlInfo> GetUrlInfo(string uriString)
        {
            _logger.LogDebug($"Start parsing: {uriString}");

            Uri uri = new(uriString);
           // var domainParser = new DomainParser(new WebTldRuleProvider());
            var domain = uri.Host;
            var hostname = uri.Host;
            var registrableDomain = uri.Host;
            var subDomain = String.Empty;
            var tld = String.Empty;
            var tldQty = 0;

           /* if (domainParser.IsValidDomain(domain))
            {
                var domainInfo = domainParser.Parse(domain);
                domain = domainInfo.Domain;
                hostname = domainInfo.Hostname;
                registrableDomain = domainInfo.RegistrableDomain;
                subDomain = domainInfo.SubDomain;
                tld = domainInfo.TLD;
                tldQty = domainInfo.TLDRule.LabelCount;
            }*/

            UrlInfo urlInfo = new() {
                Url = uri.AbsoluteUri,
                Domain = domain,
                Hostname = hostname,
                RegDomain = registrableDomain,
                UrlDigitLetterRatio = Parser.DigitLetterRatio(uri.AbsoluteUri),
                Port = uri.Port,
                TopLevelDomain = tld,
                TopLevelDomainSegments = tldQty,
                UrlLength = uri.AbsoluteUri?.Length ?? 0,
                DomainLength = uri.Host?.Length ?? 0,
                DomainDigitCount = Parser.DigitCount(domain),
                DomainContainsIp = Parser.ContainsIp(domain),
                DomainSpecialChars = Parser.SpecialChars(uri.AbsoluteUri),
                DomainNonAlphaNumeric = Parser.NonAlphaNumeric(domain),
                DomainHyphens = Parser.CountSequence(domain, "-"),
                UrlAtQty = Parser.CountSequence(uriString, "@"),
                DomainPresenceInAlexaDomains = await _urlRepository.ExistsInBeningList(domain),
                SubDomainDotsQty = Parser.CountSequence(subDomain, "."),
                PathDoubleSlashQty = Parser.CountSequence(uri.PathAndQuery, "//"),
                PathSubDirQty = uri.Segments.Length,
                PathSpaceQty = Parser.CountSequence(uri.PathAndQuery, "%20"),
                PathEncodingQty = Parser.CountSequence(uri.PathAndQuery, "%"),
                PathUpperCaseDirQty = Parser.UppercaseSegments(uri.Segments),
                PathMinLenghtDir = Parser.PathMinLength(uri.Segments),
                PathMaxLenghtDir = Parser.PathMaxLength(uri.Segments),
                PathSpecialChars = Parser.SpecialChars(uri.PathAndQuery),
                PathZerosQty = Parser.CountSequence(uri.PathAndQuery, "0"),
                PathUpperLowerCharRatio = Parser.UpperLowerRatio(uri.PathAndQuery),
                ParametersLenght = uri.Query?.Length ?? 0,
                QueryQty = uri.Query?.Length > 0 ? Parser.CountSequence(uri.Query, "&") + 1 : 0
            };

            _logger.LogDebug($"Complete parse: {urlInfo.Url}");
            return urlInfo;
        }

        public async Task<IEnumerable<CsvUrlResponse>> GetUrlInfo(IEnumerable<CsvUrlRequest> uriStrings)
        {
            ConcurrentBag<CsvUrlResponse> urlInfos = new();
            await Task.WhenAll(uriStrings.Select(async url => urlInfos.Add(new CsvUrlResponse(url, await GetUrlInfo(url.Url)))));

            return urlInfos.ToList();
        }

        public static class Parser
        {
            public static int PathMinLength(string[] source)
            {
                if(source?.Length < 2)
                    return 0;
                return source[1..].Min(x => x.Length);
            }

            public static int PathMaxLength(string[] source)
            {
                if (source?.Length < 2)
                    return 0;
                return source[1..].Max(x => x.Length);
            }
            public static double DigitLetterRatio(string source) => source.Length > 0 ? (double)source.Count(x => Char.IsDigit(x)) / source.Length : 0;
            public static int DigitCount(string source) => source.Count(x => Char.IsDigit(x));
            public static bool ContainsIp(string source)
            {
                if (source.Count(c => c == '.') != 3) return false;
                return IPAddress.TryParse(source, out _);
            }
            public static double UpperLowerRatio(string source){
                if (source?.Length == 0) return 0;
                return (double) source.Count(x => Char.IsUpper(x)) / source.Length;
            }
                
            public static int SpecialChars(string source) => Regex.Matches(source, "[~!@#$%^&*()_+{}:\"<>?]").Count;
            public static int NonAlphaNumeric(string source) => source.Count(c => !char.IsLetterOrDigit(c));
            public static int UppercaseSegments(string[] segments) => segments.Count(x => Char.IsUpper(x[0]));
            public static int CountSequence(string source, string seq)
            {
                if(source is null) return 0;
                var counter = 0;
                var index = 0;
                foreach (var c in source)
                {
                    if (c.Equals(seq[index]))
                    {
                        index++;
                        if(index == seq.Length)
                        {
                            counter++;
                            index = 0;
                        }                                                  
                        continue;
                    }
                    index = 0;             
                };
                return counter;
            }

        }
    }
}